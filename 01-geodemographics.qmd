# Geodemographics

::: {.callout-note}
This GitHub page is receiving updates for the 2024-2025 academic year. The content for 2023-2024 has been archived and can be found here: [\[Link\]](https://jtvandijk.github.io/GEOG0114_20232024)
:::

This week we will turn to geodemographic classification. Geodemographic classification is a method used to categorise geographic areas and the people living in them based on demographic, socioeconomic, and sometimes lifestyle characteristics. This approach combines geographic information with demographic data to create profiles of different neighborhoods.

## Lecture slides {#lecture-w07}
You can download the slides of this week's lecture here: [[Link]]({{< var slides.week07 >}}).

## Reading list {#reading-w07}
#### Essential readings 
- Longley, P. A. 2012. Geodemographics and the practices of geographic information science. *International Journal of Geographical Information Science* 26(12): 2227-2237. [\[Link\]](https://doi.org/10.1080/13658816.2012.719623)
- Singleton, A. and Longley, P. A. 2024. Classifying and mapping residential structure through the London Output Area Classification. *Environment and Planning B: Urban Analytics and City Science* 51(5): 1153-1164. [\[Link\]](https://doi.org/10.1177/23998083241242913)
- Wyszomierski, J., Longley, P. A., and Singleton, A. *et al.* 2023. A neighbourhood Output Area Classification from the 2021 and 2022 UK censuses. *The Geographical Journal*. Online First. [\[Link\]](https://doi.org/10.1111/geoj.12550)

#### Suggested readings 
- Fränti, P. and Sieronoja, S. 2019. How much can k-means be improved by using better initialization and repeats? *Pattern Recognition* 93: 95-112. [[Link]](https://doi.org/10.1016/j.patcog.2019.04.014)
- Singleton, A. and Spielman, S. 2014. The past, present, and future of geodemographic research in the United States and United Kingdom. *The Professional Geographer* 66(4): 558-567. [\[Link\]](https://doi.org/10.1080/00330124.2013.848764)

## London Output Area Classification
The London Output Area Classification (LOAC) is a geodemographic that summarises the built and population characteristics of all 2021 Output Areas within Greater London. The region is organised into a hierarchical typology composed of 7 Supergroups and 16 Groups, created using data from 2021 Census data. The LOAC uses 68 variables across several domains: demography, ethnicity and origins, living arrangements, usual residence, health and education and employment (see [Singleton and Longley 2024](https://doi.org/10.1177/23998083241242913)). 

Today, we will create our own geodemographic classification at the LSOA level using a subset of the 2021 Census LOAC variables to examine demographic patterns across London. Specifically, we will focus on age group, self-identified ethnicity, and country of birth. Additionally, we will include data on an individual’s first or preferred language. The data represent all usual residents as recorded in the 2021 Census for England and Wales, and have been extracted using the [Custom dataset tool](https://www.ons.gov.uk/datasets/create). You can download copies of each file via the provided links. Save these files in your project folder under `data`.

| File                                        | Type   | Link |
| :------                                     | :------| :------ |
| London LSOA Census 2021 Age Groups          | `csv` | [Download](https://github.com/jtvandijk/GEOG0114/tree/master/data/London-LSOA-AgeGroup.csv) |
| London LSOA Census 2021 Country of Birth    | `csv` | [Download](https://github.com/jtvandijk/GEOG0114/tree/master/data/London-LSOA-Country-of-Birth.csv) |
| London LSOA Census 2021 Ethnicity           | `csv` | [Download](https://github.com/jtvandijk/GEOG0114/tree/master/data/London-LSOA-Ethnicity.csv) |
| London LSOA Census 2021 Main Language       | `csv` | [Download](https://github.com/jtvandijk/GEOG0114/tree/master/data/London-LSOA-MainLanguage.csv) |

::: {.callout-note}
To download a `csv` file that is hosted on GitHub, click on the `Download raw file` button on the top right of your screen and it should download directly to your computer.
:::

We will start by loading the libraries that we will need:

```{r}
#| label: 01-load-libraries
#| classes: styled-output
#| echo: True
#| eval: True
#| output: False
#| tidy: True
#| filename: "R code"
# load libraries
library(tidyverse)
library(janitor)
library(tmap)
```

Next, we can load the individual `csv` files into R.

```{r}
#| label: 01-load-data
#| classes: styled-output
#| echo: True
#| eval: True
#| tidy: True
#| filename: "R code"
# load age data
lsoa_age <- read_csv('data/London-LSOA-AgeGroup.csv')

# load country of birth data
lsoa_cob <- read_csv('data/London-LSOA-Country-of-Birth.csv')

# load ethnicity data
lsoa_eth <- read_csv('data/London-LSOA-Ethnicity.csv')

# load language data
lsoa_lan <- read_csv('data/London-LSOA-MainLanguage.csv')
```

::: {.callout-warning}
If using a Windows machine, you may need to substitute your forward-slashes (`/`) with two backslashes (`\\`) whenever you are dealing with file paths.
:::

Let us have a look at the data:

```{r}
#| label: 01-inspect-data
#| classes: styled-output
#| echo: True
#| eval: True
#| tidy: True
#| filename: "R code"
# inspect age data
head(lsoa_age)

# inspect country of birth data
head(lsoa_cob)

# inspect ethnicity data
head(lsoa_eth)

# inspect language data
head(lsoa_lan)
```

::: {.callout-note}
You can further inspect the results using the `View()` function. 
:::

To identify geodemographic clusters in our dataset, we will use an unsupervised machine learning technique called $k$-means. $k$-means aims to partition a set of standardised observations into a specified number of clusters ($k$), where each observation is assigned to the cluster with the nearest mean. In this context, a cluster refers to a collection of data points grouped together based on certain similarities. To do this we first need to prepare the individual datase, as well as transform and standardise the input variables.

### Data preparation
Because all the data are stored in [long format](https://towardsdatascience.com/long-and-wide-formats-in-data-explained-e48d7c9a06cb), with each London LSOA having separate entries for each category, we need to transform it into a wide format. Additionally, we need to clean up the column names to align with general R naming conventions, which can be done using the `janitor` package. We will begin with the `lsoa_age` dataframe:

```{r}
#| label: 01-reformat-data-age
#| classes: styled-output
#| echo: True
#| eval: True
#| tidy: True
#| filename: "R code"
# clean names 
lsoa_age <- lsoa_age |>
  clean_names()

# pivot
lsoa_age <- lsoa_age |>
  pivot_wider(id_cols = 'lower_layer_super_output_areas_code',
              names_from = 'age_5_categories',
              values_from = 'observation') 

# clean names
lsoa_age <- lsoa_age |>
  clean_names()
```

::: {.callout-note}
The code above uses a pipe function: `|>`. The pipe operator allows you to pass the output of one function directly into the next, streamlining your code. While it might seem a bit confusing at first, you will find that it makes your code faster to write and easier to read. More importantly, it reduces the need to create multiple intermediate variables to store outputs.
:::

::: {.callout-note}
Make sure to inspect your dataframes in between steps to see what exactly is happening. 
:::

We can now transform the LSOA counts to proportions:

```{r}
#| label: 01-prop-data-age
#| classes: styled-output
#| echo: True
#| eval: True
#| tidy: True
#| filename: "R code"
# total observations
lsoa_age <- lsoa_age |>
  rowwise() |>
  mutate(age_pop = sum(across(2:6)))
  
# total proportions
lsoa_age <- lsoa_age |>
  mutate(across(2:6, ~ . / age_pop)) |>
  select(1:6)
```

This looks much better. We can do the same for the other country of birth data:

```{r}
#| label: 01-reformat-cob-data
#| classes: styled-output
#| echo: True
#| eval: True
#| tidy: True
#| filename: "R code"
# prepare country of birth data
lsoa_cob <- lsoa_cob |>
  clean_names() |>
  pivot_wider(id_cols = 'lower_layer_super_output_areas_code',
              names_from = 'country_of_birth_8_categories',
              values_from = 'observation') |>
  clean_names()

# proportions
lsoa_cob <- lsoa_cob |>
  rowwise() |>
  mutate(cob_pop = sum(across(2:9))) |>
  mutate(across(2:9, ~ . / cob_pop )) |>
  select(1:9)
```

And the final two datasets:

```{r}
#| label: 01-reformat-eth-lan-data
#| classes: styled-output
#| echo: True
#| eval: True
#| tidy: True
#| filename: "R code"
# prepare ethnicity data
lsoa_eth <- lsoa_eth |>
  clean_names() |>
  pivot_wider(id_cols = 'lower_layer_super_output_areas_code',
              names_from = 'ethnic_group_20_categories',
              values_from = 'observation') |>
  clean_names()

# proportions
lsoa_eth <- lsoa_eth |>
  rowwise() |>
  mutate(eth_pop = sum(across(2:21))) |>
  mutate(across(2:21, ~ . / eth_pop )) |>
  select(1:21)

# prepare language data
lsoa_lan <- lsoa_lan |>
  clean_names() |>
  pivot_wider(id_cols = 'lower_layer_super_output_areas_code',
              names_from = 'main_language_11_categories',
              values_from = 'observation') |>
  clean_names()

# proportions
lsoa_lan <- lsoa_lan |>
  rowwise() |>
  mutate(lan_pop = sum(across(2:12))) |>
  mutate(across(2:12, ~ . / lan_pop )) |>
  select(1:12)
```

We now have four separate datasets, each containing the proportions of usual residents classified into different groups based on age, ethnicity, language, and country of birth.


## Assignment 
The creation of a geodemographic classification is an iterative process. This typically includes adding or removing variables, adjusting the number of clusters, and grouping data in different ways to achieve the most meaningful segmentation. If you want to refine your clustering solution, you can re-run the analysis with different variables or cluster numbers by simply updating your code. However, automating parts of this process with a [function](https://en.wikipedia.org/wiki/Function_(computer_programming)) would streamline the workflow and make it more efficient.

Try to create a simple *R function* that:

1.  Takes at least three arguments: a data frame containing the input data, the number of clusters you want, and a list of input variables.
2.  Executes a k-means clustering on the specified input variables and number of clusters.
3.  Generates a `csv` file that contains a table of means for each cluster in the solution.

::: {.callout-note}
1.  Your function could be structured like this: `run-kmeans(df, k, vars)`, where `df` is your input dataframe, `k` is the number of clusters, and `vars` is a list of input variables. 
2.  For a more in-depth discussion on constructing functions in R, refer to Hadley Wickham's [R for Data Science](https://r4ds.hadley.nz/functions.html) Chapter on *Functions*.  
::: 

## Before you leave {#byl-geo}
Having finished this tutorial, you should now understand the basics of a geodemographic classification. In addition, you should now be able to write simple functions. That is [all for this week](https://www.youtube.com/watch?v=8iwBM_YB1sE)! 